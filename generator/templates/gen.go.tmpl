// Code generated by volcago. DO NOT EDIT.
// generated version: {{ .AppVersion }}
package {{ .PackageName }}

import (
	"context"
{{- if .MetaFieldsEnabled }}
	"time"
{{- end }}

	"cloud.google.com/go/firestore"
{{- if .EnableIndexes }}
	"github.com/go-utils/xim"
{{- end }}
	"golang.org/x/xerrors"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
{{- if ne .ModelImportPath "" }}

	model "{{.ModelImportPath}}"
{{- end }}
)
{{- $bracketsStart := "{" }}
{{- $bracketsEnd := "}" }}
{{ $generate := "go:generate" }}
//{{ $generate }} {{ .MockGenPath }} -source $GOFILE -destination {{ .MockOutputPath }}

// {{ .RepositoryInterfaceName }} - Repository of {{ .StructName }}
type {{ .RepositoryInterfaceName }} interface {
	// Single
	{{ GetFunc }}
	{{ GetWithDocFunc }}
	{{ InsertFunc }}
	{{ UpdateFunc }}
	{{ StrictUpdateFunc }}
	{{ DeleteFunc }}
	{{ DeleteByFunc }}
	// Multiple
	{{ GetMultiFunc }}
	{{ InsertMultiFunc }}
	{{ UpdateMultiFunc }}
	{{ DeleteMultiFunc }}
	{{ DeleteMultiByFunc }}
	// Single(Transaction)
	{{ GetWithTxFunc }}
	{{ GetWithDocWithTxFunc }}
	{{ InsertWithTxFunc }}
	{{ UpdateWithTxFunc }}
	{{ StrictUpdateWithTxFunc }}
	{{ DeleteWithTxFunc }}
	{{ DeleteByWithTxFunc }}
	// Multiple(Transaction)
	{{ GetMultiWithTxFunc }}
	{{ InsertMultiWithTxFunc }}
	{{ UpdateMultiWithTxFunc }}
	{{ DeleteMultiWithTxFunc }}
	{{ DeleteMultiByWithTxFunc }}
	// Search
	{{ SearchFunc }}
	{{ SearchWithTxFunc }}
	// misc
	GetCollection() *firestore.CollectionRef
	GetCollectionName() string
	GetDocRef({{ .KeyValueName }} string) *firestore.DocumentRef
	RunInTransaction() func(ctx context.Context, f func(context.Context, *firestore.Transaction) error, opts ...firestore.TransactionOption) (err error)
{{- if eq .IsSubCollection true }}
	SetParentDoc(doc *firestore.DocumentRef)
	Free()
{{- end }}
{{- $structNameRef := .StructNameRef }}
{{- if ne ( len .UniqueInfos ) 0 }}
	// get by unique field
{{-     range $ui := .UniqueInfos }}
	GetBy{{ $ui.Field }}(ctx context.Context, {{ ToLower $ui.FsTag }} string) (*{{ $structNameRef }}, error)
	GetBy{{ $ui.Field }}WithTx(tx *firestore.Transaction, {{ ToLower $ui.FsTag }} string) (*{{ $structNameRef }}, error)
{{-     end }}
{{- end }}
}
{{ $middlewareName := printf "%sMiddleware" .RepositoryInterfaceName }}
// {{ $middlewareName }} - middleware of {{ .RepositoryInterfaceName }}
type {{ $middlewareName }} interface {
	BeforeInsert(ctx context.Context, subject *{{ .StructNameRef }}) (bool, error)
	BeforeUpdate(ctx context.Context, old, subject *{{ .StructNameRef }}) (bool, error)
	BeforeDelete(ctx context.Context, subject *{{ .StructNameRef }}, opts ...DeleteOption) (bool, error)
	BeforeDeleteBy{{ .KeyFieldName }}(ctx context.Context, {{ PluralForm .KeyValueName }} []{{ .KeyFieldType }}, opts ...DeleteOption) (bool, error)
}

type {{ .RepositoryStructName }} struct {
	collectionName   string
	firestoreClient  *firestore.Client
{{- if eq .IsSubCollection true }}
	parentDocument   *firestore.DocumentRef
	collectionGroup  *firestore.CollectionGroupRef
{{- end }}
	middleware       []{{ $middlewareName }}
	uniqueRepository *uniqueRepository
}

// New{{ .RepositoryInterfaceName }} - constructor
func New{{ .RepositoryInterfaceName }}(firestoreClient *firestore.Client{{ if eq .IsSubCollection true }}, parentDocument *firestore.DocumentRef{{ end }}, middleware ...{{ $middlewareName }}) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		collectionName:   "{{ .CollectionName }}",
		firestoreClient:  firestoreClient,{{ if eq .IsSubCollection true }}
		parentDocument:   parentDocument,{{ end }}
		middleware:       middleware,
		uniqueRepository: newUniqueRepository(firestoreClient, "{{ .CollectionName }}"),
	}
}{{ if eq .IsSubCollection true }}

// New{{ .StructName }}CollectionGroupRepository - constructor
func New{{ .StructName }}CollectionGroupRepository(firestoreClient *firestore.Client) {{ .RepositoryInterfaceName }} {
	return &{{ .RepositoryStructName }}{
		collectionName:  "{{ .CollectionName }}",
		collectionGroup: firestoreClient.CollectionGroup("{{ .CollectionName }}"),
	}
}{{ end }}
{{ if .MetaFieldsEnabled }}
func (repo *{{ .RepositoryStructName }}) setMeta(subject *{{ .StructNameRef }}, isInsert bool) {
	now := time.Now()

	if isInsert {
		subject.CreatedAt = now
	}
	subject.UpdatedAt = now
	subject.Version++
}

func (repo *{{ .RepositoryStructName }}) setMetaWithStrictUpdate(param *{{ .StructName }}UpdateParam) {
	param.UpdatedAt = firestore.ServerTimestamp
	param.Version = firestore.Increment(1)
}
{{ end }}
func (repo *{{ .RepositoryStructName }}) beforeInsert(ctx context.Context, subject *{{ .StructNameRef }}) (RollbackFunc, error) {
{{- if .MetaFieldsEnabled }}
	if subject.Version != 0 {
		return nil, xerrors.Errorf("insert data must be Version == 0 %+v: %w", subject, ErrVersionConflict)
	}
	if subject.DeletedAt != nil {
		return nil, xerrors.Errorf("insert data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, true)
{{- end }}
	repo.uniqueRepository.setMiddleware(ctx)
	rb, err := repo.uniqueRepository.CheckUnique(ctx, nil, subject)
	if err != nil {
		return nil, xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeInsert(ctx, subject)
		if err != nil {
			return nil, xerrors.Errorf("beforeInsert.middleware error(uniqueRB=%t): %w", rb(ctx) == nil, err)
		}
		if !c {
			continue
		}
	}

	return rb, nil
}

func (repo *{{ .RepositoryStructName }}) beforeUpdate(ctx context.Context, old, subject *{{ .StructNameRef }}) (RollbackFunc, error) {
	if ctx.Value(transactionInProgressKey{}) != nil && old == nil {
		var err error
		doc := repo.GetDocRef(subject.{{ .KeyFieldName }})
		old, err = repo.get(context.Background(), doc)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return nil, ErrNotFound
			}
			return nil, xerrors.Errorf("error in Get method: %w", err)
		}
	}
{{- if .MetaFieldsEnabled }}
	if old.Version > subject.Version {
		return nil, xerrors.Errorf(
			"The data in the database is newer: (db version: %d, target version: %d) %+v: %w",
			old.Version, subject.Version, subject, ErrVersionConflict,
		)
	}
	if subject.DeletedAt != nil {
		return nil, xerrors.Errorf("update data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, false)
{{- end }}
	repo.uniqueRepository.setMiddleware(ctx)
	rb, err := repo.uniqueRepository.CheckUnique(ctx, old, subject)
	if err != nil {
		return nil, xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeUpdate(ctx, old, subject)
		if err != nil {
			return nil, xerrors.Errorf("beforeUpdate.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}

	return rb, nil
}

func (repo *{{ .RepositoryStructName }}) beforeDelete(ctx context.Context, subject *{{ .StructNameRef }}, opts ...DeleteOption) (RollbackFunc, error) {
{{- if .MetaFieldsEnabled }}
	repo.setMeta(subject, false)
{{- end }}
	repo.uniqueRepository.setMiddleware(ctx)
	rb, err := repo.uniqueRepository.DeleteUnique(ctx, subject)
	if err != nil {
		return nil, xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeDelete(ctx, subject, opts...)
		if err != nil {
			return nil, xerrors.Errorf("beforeDelete.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}

	return rb, nil
}

// GetCollection - *firestore.CollectionRef getter
func (repo *{{ .RepositoryStructName }}) GetCollection() *firestore.CollectionRef {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil
	}
{{- end }}
	return repo.{{ if eq .IsSubCollection true }}parentDocument{{ else }}firestoreClient{{ end }}.Collection(repo.collectionName)
}

// GetCollectionName - CollectionName getter
func (repo *{{ .RepositoryStructName }}) GetCollectionName() string {
	return repo.collectionName
}

// GetDocRef - *firestore.DocumentRef getter
func (repo *{{ .RepositoryStructName }}) GetDocRef({{ .KeyValueName }} string) *firestore.DocumentRef {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil
	}
{{- end }}
	return repo.GetCollection().Doc({{ .KeyValueName }})
}

// RunInTransaction - (*firestore.Client).RunTransaction getter
func (repo *{{ .RepositoryStructName }}) RunInTransaction() func(ctx context.Context, f func(context.Context, *firestore.Transaction) error, opts ...firestore.TransactionOption) (err error) {
	return repo.firestoreClient.RunTransaction
}
{{- if eq .IsSubCollection true }}

// SetParentDoc - parent document setter
func (repo *{{ .RepositoryStructName }}) SetParentDoc(doc *firestore.DocumentRef) {
	if doc == nil {
		return
	}
	repo.parentDocument = doc
}

// Free - parent document releaser
func (repo *{{ .RepositoryStructName }}) Free() {
	repo.parentDocument = nil
}
{{- end }}
{{ if .EnableIndexes }}
func (repo *{{ .RepositoryStructName }}) saveIndexes(subject *{{ .StructNameRef }}) error {
	idx := xim.NewIndexes(&xim.Config{
		IgnoreCase:         true,
		SaveNoFiltersIndex: true,
	})
	{{ $bracketsStart}}
{{- range $fi := .FieldInfos }}
{{- 	range $index := $fi.Indexes }}
{{- 		if eq $index.Use true }}
		idx.{{ if HasSuffix $index.Method "fix" }}{{ PluralForm $index.Method }}{{ else }}{{ $index.Method }}{{ end }}({{ $index.ConstName }}, subject.{{ $fi.Field }})
{{- 		end }}
{{- 	end }}
{{- end }}
	{{ $bracketsEnd}}
	indexes, err := idx.Build()
	if err != nil {
		return xerrors.Errorf("failed to index build: %w", err)
	} else if len(indexes) == 0 {
		return nil
	}

	subject.Indexes = indexes

	return nil
}
{{ end }}
// {{ .StructName }}SearchParam - params for search
type {{ .StructName }}SearchParam struct {
{{ GenerateSearchParam .FieldInfos }}
{{- if .MetaFieldsEnabled }}

	IncludeSoftDeleted bool
	CursorLimit        int
{{- else }}

	CursorLimit int
{{- end  }}
}

// {{ .StructName }}UpdateParam - params for strict updates
type {{ .StructName }}UpdateParam struct {
{{ GenerateUpdateParam .FieldInfos }}
}

// Search - search documents
// The third argument is firestore.Query, basically you can pass nil
func (repo *{{ .RepositoryStructName }}) {{ SearchFunc }} {
	return repo.search(ctx, param, q)
}

// Get - get `{{ .StructName }}` by `{{ .StructName }}.{{ .KeyFieldName }}`
func (repo *{{ .RepositoryStructName }}) {{ GetFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	doc := repo.GetDocRef({{ .KeyValueName }})
	return repo.get(ctx, doc, opts...)
}

// GetWithDoc - get `{{ .StructName }}` by *firestore.DocumentRef
func (repo *{{ .RepositoryStructName }}) {{ GetWithDocFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	return repo.get(ctx, doc, opts...)
}

// Insert - insert of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ InsertFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return "", ErrNotAvailableCG
	}
{{- end }}
	rb, err := repo.beforeInsert(ctx, subject)
	if err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique check error %+v, original error: %w", er, err)
			}
		}
	}()
{{ if eq .EnableIndexes true}}
	if err = repo.saveIndexes(subject); err != nil {
		return "", xerrors.Errorf("failed to saveIndexes: %w", err)
	}
{{ end }}
	return repo.insert(ctx, subject)
}

// Update - update of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ UpdateFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	doc := repo.GetDocRef(subject.{{ .KeyFieldName }})

	old, err := repo.get(ctx, doc)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return ErrNotFound
		}
		return xerrors.Errorf("error in Get method: %w", err)
	}

	rb, err := repo.beforeUpdate(ctx, old, subject)
	if err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique check error %+v, original error: %w", er, err)
			}
		}
	}()
{{ if eq .EnableIndexes true}}
	if err := repo.saveIndexes(subject); err != nil {
		return xerrors.Errorf("failed to saveIndexes: %w", err)
	}
{{ end }}
	return repo.update(ctx, subject)
}

// StrictUpdate - strict update of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ StrictUpdateFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	return repo.strictUpdate(ctx, id, param, opts...)
}

// Delete - delete of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ DeleteFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
{{- if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(ctx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}
{{ end }}
	rb, err := repo.beforeDelete(ctx, subject, opts...)
	if err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique delete error %+v, original error: %w", er, err)
			}
		}
	}()

	return repo.deleteBy{{ .KeyFieldName }}(ctx, subject.{{ .KeyFieldName }})
}

// DeleteBy{{ .KeyFieldName }} - delete `{{ .StructName }}` by `{{ .StructName }}.{{ .KeyFieldName }}`
func (repo *{{ .RepositoryStructName }}) {{ DeleteByFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	subject, err := repo.Get(ctx, {{ .KeyValueName }})
	if err != nil {
		return xerrors.Errorf("error in Get method: %w", err)
	}
{{ if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(ctx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}
{{ end }}
	return repo.Delete(ctx, subject, opts...)
}

// GetMulti - get `{{ .StructName }}` in bulk by array of `{{ .StructName }}.{{ .KeyFieldName }}`
func (repo *{{ .RepositoryStructName }}) {{ GetMultiFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	return repo.getMulti(ctx, {{ PluralForm .KeyValueName }}, opts...)
}

// InsertMulti - bulk insert of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ InsertMultiFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique check error %+v, original error: %w", errs, er)
	}()

	{{ PluralForm .KeyValueName }} := make([]{{ .KeyFieldType }}, 0, len(subjects))
	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		var ref *firestore.DocumentRef
		if subject.{{ .KeyFieldName }} == "" {
			ref = collect.NewDoc()
			subject.{{ .KeyFieldName }} = ref.ID
		} else {
			ref = collect.Doc(subject.{{ .KeyFieldName }})
			if s, err := ref.Get(ctx); err == nil {
				return nil, xerrors.Errorf("already exists [%v]: %#v", subject.{{ .KeyFieldName }}, s)
			}
		}

		rb, err := repo.beforeInsert(ctx, subject)
		if err != nil {
			return nil, xerrors.Errorf("before insert error(%d) [%v]: %w", i, subject.{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{ if eq .EnableIndexes true}}
		if err := repo.saveIndexes(subjects[i]); err != nil {
			return nil, xerrors.Errorf("failed to saveIndexes: %w", err)
		}
{{ end }}
		batch.Set(ref, subject)
		{{ PluralForm .KeyValueName }} = append({{ PluralForm .KeyValueName }}, ref.ID)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return nil, xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return {{ PluralForm .KeyValueName }}, nil
}

// UpdateMulti - bulk update of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ UpdateMultiFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique check error %+v, original error: %w", errs, er)
	}()

	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.{{ .KeyFieldName }})
		snapShot, err := ref.Get(ctx)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.{{ .KeyFieldName }}, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.{{ .KeyFieldName }}, err)
		}

		old := new({{ .StructNameRef }})
		if err = snapShot.DataTo(&old); err != nil {
			return xerrors.Errorf("error in DataTo method: %w", err)
		}

		rb, err := repo.beforeUpdate(ctx, old, subject)
		if err != nil {
			return xerrors.Errorf("before update error(%d) [%v]: %w", i, subject.{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{ if eq .EnableIndexes true}}
		if err := repo.saveIndexes(subjects[i]); err != nil {
			return xerrors.Errorf("failed to saveIndexes: %w", err)
		}
{{ end }}
		batch.Set(ref, subject)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMulti - bulk delete of `{{ .StructName }}`
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique delete error %+v, original error: %w", errs, er)
	}()

	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.{{ .KeyFieldName }})
		if _, err := ref.Get(ctx); err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.{{ .KeyFieldName }}, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.{{ .KeyFieldName }}, err)
		}

		rb, err := repo.beforeDelete(ctx, subject, opts...)
		if err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subject.{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{ if .MetaFieldsEnabled }}
		if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
			t := time.Now()
			subject.DeletedAt = &t
			batch.Set(ref, subject)
		} else {
			batch.Delete(ref)
		}
{{ else }}
		batch.Delete(ref)
{{ end }}
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMultiBy{{ PluralForm .KeyFieldName }} - delete `{{ .StructName }}` in bulk by array of `{{ .StructName }}.{{ .KeyFieldName }}`
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiByFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	subjects := make([]*{{ .StructNameRef }}, len({{ PluralForm .KeyValueName }}))

	opt := GetOption{}
	if len(opts) > 0 {
		opt.IncludeSoftDeleted = opts[0].Mode == DeleteModeHard
	}
	for i, {{ .KeyValueName }} := range {{ PluralForm .KeyValueName }} {
		subject, err := repo.Get(ctx, {{ .KeyValueName }}, opt)
		if err != nil {
			return xerrors.Errorf("error in Get method: %w", err)
		}
		subjects[i] = subject
	}

	return repo.DeleteMulti(ctx, subjects, opts...)
}

func (repo *{{ .RepositoryStructName }}) {{ SearchWithTxFunc }} {
	return repo.search(tx, param, q)
}

// GetWithTx - get `{{ .StructName }}` by `{{ .StructName }}.{{ .KeyFieldName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ GetWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	doc := repo.GetDocRef({{ .KeyValueName }})
	return repo.get(tx, doc, opts...)
}

// GetWithDocWithTx - get `{{ .StructName }}` by *firestore.DocumentRef in transaction
func (repo *{{ .RepositoryStructName }}) {{ GetWithDocWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	return repo.get(tx, doc, opts...)
}

// InsertWithTx - insert of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ InsertWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return "", ErrNotAvailableCG
	}
{{- end }}
	rb, err := repo.beforeInsert(context.WithValue(ctx, transactionInProgressKey{}, 1), subject)
	if err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique check error %+v, original error: %w", er, err)
			}
		}
	}()
{{ if eq .EnableIndexes true}}
	if err := repo.saveIndexes(subject); err != nil {
		return "", xerrors.Errorf("failed to saveIndexes: %w", err)
	}
{{ end }}
	return repo.insert(tx, subject)
}

// UpdateWithTx - update of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ UpdateWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	rb, err := repo.beforeUpdate(context.WithValue(ctx, transactionInProgressKey{}, 1), nil, subject)
	if err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique check error %+v, original error: %w", er, err)
			}
		}
	}()
{{ if eq .EnableIndexes true}}
	if err := repo.saveIndexes(subject); err != nil {
		return xerrors.Errorf("failed to saveIndexes: %w", err)
	}
{{ end }}
	return repo.update(tx, subject)
}

// StrictUpdateWithTx - strict update of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ StrictUpdateWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	return repo.strictUpdate(tx, id, param, opts...)
}

// DeleteWithTx - delete of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ DeleteWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
{{- if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(tx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}
{{ end }}
	rb, err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, 1), subject, opts...)
	if err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique check error %+v, original error: %w", er, err)
			}
		}
	}()

	return repo.deleteBy{{ .KeyFieldName }}(tx, subject.{{ .KeyFieldName }})
}

// DeleteBy{{ .KeyFieldName }}WithTx - delete `{{ .StructName }}` by `{{ .StructName }}.{{ .KeyFieldName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ DeleteByWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	subject, err := repo.Get(context.Background(), {{ .KeyValueName }})
	if err != nil {
		return xerrors.Errorf("error in Get method: %w", err)
	}
{{ if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(tx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}
{{ end }}
	rb, err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, 1), subject, opts...)
	if err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}
	defer func() {
		if err != nil {
			if er := rb(ctx); er != nil {
				err = xerrors.Errorf("unique delete error %+v, original error: %w", er, err)
			}
		}
	}()

	return repo.deleteBy{{ .KeyFieldName }}(tx, {{ .KeyValueName }})
}

// GetMultiWithTx - get `{{ .StructName }}` in bulk by array of `{{ .StructName }}.{{ .KeyFieldName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ GetMultiWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	return repo.getMulti(tx, {{ PluralForm .KeyValueName }}, opts...)
}

// InsertMultiWithTx - bulk insert of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ InsertMultiWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return nil, ErrNotAvailableCG
	}
{{- end }}
	ctx = context.WithValue(ctx, transactionInProgressKey{}, 1)
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique check error %+v, original error: %w", errs, er)
	}()
{{ if not .AutomaticGeneration }}
	for i := range subjects {
		if _, err := tx.Get(new(firestore.DocumentRef)); err == nil {
			return nil, xerrors.Errorf("already exists(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
	}
{{ end }}
	{{ PluralForm .KeyValueName }} := make([]string, len(subjects))

	for i := range subjects {
		rb, err := repo.beforeInsert(ctx, subjects[i])
		if err != nil {
			return nil, xerrors.Errorf("before insert error(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{ if eq .EnableIndexes true}}
		if err := repo.saveIndexes(subjects[i]); err != nil {
			return nil, xerrors.Errorf("failed to saveIndexes: %w", err)
		}
{{ end }}
		{{ .KeyValueName }}, err := repo.insert(tx, subjects[i])
		if err != nil {
			return nil, xerrors.Errorf("error in insert method(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
		{{ PluralForm .KeyValueName }}[i] = {{ .KeyValueName }}
	}

	return {{ PluralForm .KeyValueName }}, nil
}

// UpdateMultiWithTx - bulk update of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ UpdateMultiWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	ctx = context.WithValue(ctx, transactionInProgressKey{}, 1)
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique check error %+v, original error: %w", errs, er)
	}()

	ctx = context.WithValue(ctx, transactionInProgressKey{}, 1)
	for i := range subjects {
		rb, err := repo.beforeUpdate(ctx, nil, subjects[i])
		if err != nil {
			return xerrors.Errorf("before update error(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
	}

	for i := range subjects {
{{- if eq .EnableIndexes true}}
		if err := repo.saveIndexes(subjects[i]); err != nil {
			return xerrors.Errorf("failed to saveIndexes: %w", err)
		}
{{- end }}
		if err := repo.update(tx, subjects[i]); err != nil {
			return xerrors.Errorf("error in update method(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
	}

	return nil
}

// DeleteMultiWithTx - bulk delete of `{{ .StructName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique delete error %+v, original error: %w", errs, er)
	}()
{{ if .MetaFieldsEnabled }}
	t := time.Now()
{{- end }}
	var isHardDeleteMode bool
	if len(opts) > 0 {
		isHardDeleteMode = opts[0].Mode == DeleteModeHard
	}
	opt := GetOption{
		IncludeSoftDeleted: isHardDeleteMode,
	}
	for i := range subjects {
		dr := repo.GetDocRef(subjects[i].{{ .KeyFieldName }})
		if _, err := repo.get(context.Background(), dr, opt); err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found(%d) [%v]", i, subjects[i].{{ .KeyFieldName }})
			}
			return xerrors.Errorf("error in get method(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}

		rb, err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, 1), subjects[i], opts...)
		if err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{- if .MetaFieldsEnabled }}

		if !isHardDeleteMode {
			subjects[i].DeletedAt = &t
			if err := repo.update(tx, subjects[i]); err != nil {
				return xerrors.Errorf("error in update method(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
			}
		}
{{- end }}
	}
{{ if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		return nil
	}
{{ end }}
	for i := range subjects {
		if err := repo.deleteBy{{ .KeyFieldName }}(tx, subjects[i].{{ .KeyFieldName }}); err != nil {
			return xerrors.Errorf("error in delete method(%d) [%v]: %w", i, subjects[i].{{ .KeyFieldName }}, err)
		}
	}

	return nil
}

// DeleteMultiBy{{ .KeyFieldName }}WithTx - delete `{{ .StructName }}` in bulk by array of `{{ .StructName }}.{{ .KeyFieldName }}` in transaction
func (repo *{{ .RepositoryStructName }}) {{ DeleteMultiByWithTxFunc }} {
{{- if eq .IsSubCollection true }}
	if repo.collectionGroup != nil {
		return ErrNotAvailableCG
	}
{{- end }}
	var rbs []RollbackFunc
	defer func() {
		if er == nil {
			return
		}
		if len(rbs) == 0 {
			return
		}
		errs := make([]error, 0)
		for _, rb := range rbs {
			if err := rb(ctx); err != nil {
				errs = append(errs, err)
			}
		}
		er = xerrors.Errorf("unique delete error %+v, original error: %w", errs, er)
	}()
{{ if .MetaFieldsEnabled }}
	t := time.Now()
{{- end }}
	for i := range {{ PluralForm .KeyValueName }} {
		dr := repo.GetDocRef({{ PluralForm .KeyValueName }}[i])
		subject, err := repo.get(context.Background(), dr)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found(%d) [%v]", i, {{ PluralForm .KeyValueName }}[i])
			}
			return xerrors.Errorf("error in get method(%d) [%v]: %w", i, {{ PluralForm .KeyValueName }}[i], err)
		}

		rb, err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, 1), subject, opts...)
		if err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subject.{{ .KeyFieldName }}, err)
		}
		rbs = append(rbs, rb)
{{- if .MetaFieldsEnabled }}

		if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
			subject.DeletedAt = &t
			if err := repo.update(tx, subject); err != nil {
				return xerrors.Errorf("error in update method(%d) [%v]: %w", i, {{ PluralForm .KeyValueName }}[i], err)
			}
		}
{{- end }}
	}
{{ if .MetaFieldsEnabled }}
	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		return nil
	}
{{ end }}
	for i := range {{ PluralForm .KeyValueName }} {
		if err := repo.deleteBy{{ .KeyFieldName }}(tx, {{ PluralForm .KeyValueName }}[i]); err != nil {
			return xerrors.Errorf("error in delete method(%d) [%v]: %w", i, {{ PluralForm .KeyValueName }}[i], err)
		}
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) get(v interface{}, doc *firestore.DocumentRef, {{ if .MetaFieldsEnabled }}opts{{ else }}_{{ end }} ...GetOption) (*{{ .StructNameRef }}, error) {
	var (
		snapShot *firestore.DocumentSnapshot
		err      error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		snapShot, err = x.Get(doc)
	case context.Context:
		snapShot, err = doc.Get(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", x)
	}

	if err != nil {
		if status.Code(err) == codes.NotFound {
			return nil, ErrNotFound
		}
		return nil, xerrors.Errorf("error in Get method: %w", err)
	}

	subject := new({{ .StructNameRef }})
	if err := snapShot.DataTo(&subject); err != nil {
		return nil, xerrors.Errorf("error in DataTo method: %w", err)
	}
{{ if .MetaFieldsEnabled }}
	if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
		if subject.DeletedAt != nil {
			return nil, ErrAlreadyDeleted
		}
	}
{{- end }}
	subject.{{ .KeyFieldName }} = snapShot.Ref.ID

	return subject, nil
}

func (repo *{{ .RepositoryStructName }}) getMulti(v interface{}, {{ PluralForm .KeyValueName }} []{{ .KeyFieldType }}, {{ if .MetaFieldsEnabled }}opts{{ else }}_{{ end }} ...GetOption) ([]*{{ .StructNameRef }}, error) {
	var (
		snapShots []*firestore.DocumentSnapshot
		err       error
		collect   = repo.GetCollection()
		drs       = make([]*firestore.DocumentRef, len({{ PluralForm .KeyValueName }}))
	)

	for i, {{ .KeyValueName }} := range {{ PluralForm .KeyValueName }} {
		ref := collect.Doc({{ .KeyValueName }})
		drs[i] = ref
	}

	switch x := v.(type) {
	case *firestore.Transaction:
		snapShots, err = x.GetAll(drs)
	case context.Context:
		snapShots, err = repo.firestoreClient.GetAll(x, drs)
	default:
		return nil, xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return nil, xerrors.Errorf("error in GetAll method: %w", err)
	}

	subjects := make([]*{{ .StructNameRef }}, 0, len({{ PluralForm .KeyValueName }}))
	mErr := NewMultiErrors()
	for i, snapShot := range snapShots {
		if !snapShot.Exists() {
			mErr = append(mErr, NewMultiError(i, ErrNotFound))
			continue
		}

		subject := new({{ .StructNameRef }})
		if err = snapShot.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}
{{ if .MetaFieldsEnabled }}
		if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
			if subject.DeletedAt != nil {
				mErr = append(mErr, NewMultiError(i, ErrLogicallyDeletedData))
				continue
			}
		}
{{- end }}
		subject.{{ .KeyFieldName }} = snapShot.Ref.ID
		subjects = append(subjects, subject)
	}

	if len(mErr) == 0 {
		return subjects, nil
	}

	return subjects, mErr
}

func (repo *{{ .RepositoryStructName }}) insert(v interface{}, subject *{{ .StructNameRef }}) ({{ .KeyFieldType }}, error) {
	var (
{{- if .AutomaticGeneration }}
		dr  = repo.GetCollection().NewDoc()
{{- else }}
		dr  = repo.GetDocRef(subject.{{ .KeyFieldName }})
{{- end }}
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Create(dr, subject)
	case context.Context:
		_, err = dr.Create(x, subject)
	default:
		return "", xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		if status.Code(err) == codes.AlreadyExists {
			return "", xerrors.Errorf("error in Create method: err=%+v: %w", err, ErrAlreadyExists)
		}
		return "", xerrors.Errorf("error in Create method: %w", err)
	}

	subject.{{ .KeyFieldName }} = dr.ID

	return dr.ID, nil
}

func (repo *{{ .RepositoryStructName }}) update(v interface{}, subject *{{ .StructNameRef }}) error {
	var (
		dr  = repo.GetDocRef(subject.{{ .KeyFieldName }})
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Set(dr, subject)
	case context.Context:
		_, err = dr.Set(x, subject)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Set method: %w", err)
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) strictUpdate(v interface{}, id string, param *{{ .StructName }}UpdateParam, opts ...firestore.Precondition) error {
	var (
		dr  = repo.GetDocRef(id)
		err error
	)
{{ if .MetaFieldsEnabled }}
	repo.setMetaWithStrictUpdate(param)
{{ end }}
	updates := updater({{ .StructNameRef }}{}, param)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Update(dr, updates, opts...)
	case context.Context:
		_, err = dr.Update(x, updates, opts...)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Update method: %w", err)
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) deleteBy{{ .KeyFieldName }}(v interface{}, {{ .KeyValueName }} {{ .KeyFieldType }}) error {
	dr := repo.GetDocRef({{ .KeyValueName }})
	var err error

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Delete(dr, firestore.Exists)
	case context.Context:
		_, err = dr.Delete(x, firestore.Exists)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Delete method: %w", err)
	}

	return nil
}

func (repo *{{ .RepositoryStructName }}) runQuery(v interface{}, query firestore.Query) ([]*{{ .StructNameRef }}, error) {
	var iter *firestore.DocumentIterator

	switch x := v.(type) {
	case *firestore.Transaction:
		iter = x.Documents(query)
	case context.Context:
		iter = query.Documents(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", v)
	}

	defer iter.Stop()

	subjects := make([]*{{ .StructNameRef }}, 0)

	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, xerrors.Errorf("error in Next method: %w", err)
		}

		subject := new({{ .StructNameRef }})

		if err := doc.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}

		subject.{{ .KeyFieldName }} = doc.Ref.ID
		subjects = append(subjects, subject)
	}

	return subjects, nil
}

// BUG(54m): there may be potential bugs
func (repo *{{ .RepositoryStructName }}) search(v interface{}, param *{{ .StructName }}SearchParam, q *firestore.Query) ([]*{{ .StructNameRef }}, error) {
	if (param == nil && q == nil) || (param != nil && q != nil) {
		return nil, xerrors.New("either one should be nil")
	}

	query := func() firestore.Query {
		if q != nil {
			return *q
		}
{{- if eq .IsSubCollection true }}
		if repo.collectionGroup != nil {
			return repo.collectionGroup.Query
		}
{{- end }}
		return repo.GetCollection().Query
	}()

	if q == nil {
{{- if .EnableIndexes }}
		filters := xim.NewFilters(&xim.Config{
			IgnoreCase:         true,
			SaveNoFiltersIndex: true,
		})
{{ end }}
{{- $Meta := .MetaFieldsEnabled }}
{{- $EnableIndexes := .EnableIndexes }}
{{- $RepositoryStructName := .RepositoryStructName }}
{{- range $fi := .FieldInfos }}
{{- 	$IsSlice := HasSlice $fi.FieldType }}
{{- 	$IsMap := HasMap $fi.FieldType }}
		if param.{{ $fi.Field }} != nil {
{{- 		if eq $IsMap true }}
			for _, chain := range param.{{ $fi.Field }}.QueryGroup {
				items, ok := chain.Value.({{ $fi.FieldType }})
				if !ok {
					continue
				}
				for key, value := range items {
					query = query.WherePath(firestore.FieldPath{{ $bracketsStart }}"{{ $fi.FsTag }}", key{{ $bracketsEnd }}, chain.Operator, value)
				}
			}
{{- 		else if eq $IsSlice true }}
			for _, chain := range param.{{ $fi.Field }}.QueryGroup {
				query = query.Where("{{ $fi.FsTag }}", chain.Operator, chain.Value)
			}
{{- 		else }}
			for _, chain := range param.{{ $fi.Field }}.QueryGroup {
				query = query.Where("{{ $fi.FsTag }}", chain.Operator, chain.Value)
			}
			if direction := param.{{ $fi.Field }}.OrderByDirection; direction > 0 {
				query = query.OrderBy("{{ $fi.FsTag }}", direction)
				query = param.{{ $fi.Field }}.BuildCursorQuery(query)
			}
{{- 			if and (eq $EnableIndexes true ) (ne ( len $fi.Indexes ) 0) }}
			value, ok := param.{{ $fi.Field }}.Filter.Value.(string)
{{- 				$indexerInfo := IndexerInfo $fi }}
{{- 				if ne $indexerInfo "" }}
			{{ print $indexerInfo }}
{{- 				end }}
			for _, filter := range param.{{ $fi.Field }}.Filter.FilterTypes {
				switch filter {
{{- 				$EqualLabel := "" }}
{{- 				range $filters := $fi.Indexes }}
{{- 					if eq (HasSuffix $filters.ConstName "Equal") true }}
							{{- $EqualLabel = $filters.ConstName }}
{{- 					end }}
{{- 					if and (ne $filters.Method "AddSomething" ) (eq $filters.Use true) }}
{{- 						if ne $filters.Method "Add" }}
				case {{ if eq $filters.Method "AddPrefix" }}FilterTypeAddPrefix{{ else if eq $filters.Method "AddSuffix" }}FilterTypeAddSuffix{{ else if eq $filters.Method "AddBiunigrams" }}FilterTypeAddBiunigrams{{ end }}:
					if ok {
						filters.{{ $filters.Method }}({{ $filters.ConstName }}, value)
					}
{{- 						end }}
{{- 					end }}
{{- 				end }}
				// Treat `Add` or otherwise as `Equal`.
				case FilterTypeAdd:
					fallthrough
				default:
					if !ok {
						filters.AddSomething({{ $EqualLabel }}, param.{{ $fi.Field }}.Filter.Value)
						continue
					}
					filters.Add({{ $EqualLabel }}, value)
				}
			}
{{- 			end }}
{{- 		end }}
		}
{{- end }}
{{- if .MetaFieldsEnabled }}
		if !param.IncludeSoftDeleted {
			query = query.Where("{{ (LookUpFieldByName .FieldInfos "DeletedAt").FsTag }}", OpTypeEqual, nil)
		}
{{- end }}
{{ if .EnableIndexes }}
		build, err := filters.Build()
		if err != nil {
			return nil, xerrors.Errorf("failed to filter build: %w", err)
		}
		for key := range build {
			query = query.WherePath(firestore.FieldPath{{ $bracketsStart }}"{{ .FieldInfoForIndexes.FsTag }}", key{{ $bracketsEnd}}, OpTypeEqual, true)
		}
{{ end }}
		if l := param.CursorLimit; l > 0 {
			query = query.Limit(l)
		}
	}

	return repo.runQuery(v, query)
}
{{- if ne ( len .UniqueInfos ) 0 }}
{{- $repositoryStructName := .RepositoryStructName }}
{{- range $ui := .UniqueInfos }}

// GetBy{{ $ui.Field }} - get by {{ $ui.Field }}
func (repo *{{ $repositoryStructName }}) GetBy{{ $ui.Field }}(ctx context.Context, {{ ToLower $ui.FsTag }} string) (*{{ $structNameRef }}, error) {
	return repo.getByXXX(ctx, "{{ $ui.FsTag }}", {{ ToLower $ui.FsTag }})
}

// GetBy{{ $ui.Field }}WithTx - get by {{ $ui.Field }} in transaction
func (repo *{{ $repositoryStructName }}) GetBy{{ $ui.Field }}WithTx(tx *firestore.Transaction, {{ ToLower $ui.FsTag }} string) (*{{ $structNameRef }}, error) {
	return repo.getByXXX(tx, "{{ $ui.FsTag }}", {{ ToLower $ui.FsTag }})
}
{{- end }}

func (repo *{{ .RepositoryStructName }}) getByXXX(v interface{}, field, value string) (*{{ $structNameRef }}, error) {
	query := repo.GetCollection().Query.Where(field, OpTypeEqual, value)
	results, err := repo.runQuery(v, query)
	if err != nil {
		return nil, xerrors.Errorf("failed to run query: %w", err)
	} else if len(results) == 0 {
		return nil, ErrNotFound
	}
	return results[0], nil
}
{{- end }}
