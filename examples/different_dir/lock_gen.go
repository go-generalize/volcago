// Code generated by volcago. DO NOT EDIT.
// generated version: (devel)
package repository

import (
	"context"
	"time"

	"cloud.google.com/go/firestore"
	"golang.org/x/xerrors"
	"google.golang.org/api/iterator"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	model "github.com/go-generalize/volcago/examples"
)

//go:generate ../../bin/mockgen -source $GOFILE -destination mock/lock_gen.go

// LockRepository - Repository of Lock
type LockRepository interface {
	// Single
	Get(ctx context.Context, id string, opts ...GetOption) (*model.Lock, error)
	GetWithDoc(ctx context.Context, doc *firestore.DocumentRef, opts ...GetOption) (*model.Lock, error)
	Insert(ctx context.Context, subject *model.Lock) (_ string, err error)
	Update(ctx context.Context, subject *model.Lock) (err error)
	StrictUpdate(ctx context.Context, id string, param *LockUpdateParam, opts ...firestore.Precondition) error
	Delete(ctx context.Context, subject *model.Lock, opts ...DeleteOption) (err error)
	DeleteByID(ctx context.Context, id string, opts ...DeleteOption) (err error)
	// Multiple
	GetMulti(ctx context.Context, ids []string, opts ...GetOption) ([]*model.Lock, error)
	InsertMulti(ctx context.Context, subjects []*model.Lock) (_ []string, er error)
	UpdateMulti(ctx context.Context, subjects []*model.Lock) (er error)
	DeleteMulti(ctx context.Context, subjects []*model.Lock, opts ...DeleteOption) (er error)
	DeleteMultiByIDs(ctx context.Context, ids []string, opts ...DeleteOption) (er error)
	// Single(Transaction)
	GetWithTx(tx *firestore.Transaction, id string, opts ...GetOption) (*model.Lock, error)
	GetWithDocWithTx(tx *firestore.Transaction, doc *firestore.DocumentRef, opts ...GetOption) (*model.Lock, error)
	InsertWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock) (_ string, err error)
	UpdateWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock) (err error)
	StrictUpdateWithTx(tx *firestore.Transaction, id string, param *LockUpdateParam, opts ...firestore.Precondition) error
	DeleteWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock, opts ...DeleteOption) (err error)
	DeleteByIDWithTx(ctx context.Context, tx *firestore.Transaction, id string, opts ...DeleteOption) (err error)
	// Multiple(Transaction)
	GetMultiWithTx(tx *firestore.Transaction, ids []string, opts ...GetOption) ([]*model.Lock, error)
	InsertMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock) (_ []string, er error)
	UpdateMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock) (er error)
	DeleteMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock, opts ...DeleteOption) (er error)
	DeleteMultiByIDsWithTx(ctx context.Context, tx *firestore.Transaction, ids []string, opts ...DeleteOption) (er error)
	// Search
	Search(ctx context.Context, param *LockSearchParam, q *firestore.Query) ([]*model.Lock, error)
	SearchWithTx(tx *firestore.Transaction, param *LockSearchParam, q *firestore.Query) ([]*model.Lock, error)
	SearchByParam(ctx context.Context, param *LockSearchParam) ([]*model.Lock, *PagingResult, error)
	SearchByParamWithTx(tx *firestore.Transaction, param *LockSearchParam) ([]*model.Lock, *PagingResult, error)
	// misc
	GetCollection() *firestore.CollectionRef
	GetCollectionName() string
	GetDocRef(id string) *firestore.DocumentRef
	RunInTransaction() func(ctx context.Context, f func(context.Context, *firestore.Transaction) error, opts ...firestore.TransactionOption) (err error)
	// get by unique field
	GetByText(ctx context.Context, text string, opts ...GetOption) (*model.Lock, error)
	GetByTextWithTx(tx *firestore.Transaction, text string, opts ...GetOption) (*model.Lock, error)
	GetByEmail(ctx context.Context, email string, opts ...GetOption) (*model.Lock, error)
	GetByEmailWithTx(tx *firestore.Transaction, email string, opts ...GetOption) (*model.Lock, error)
}

// LockRepositoryMiddleware - middleware of LockRepository
type LockRepositoryMiddleware interface {
	BeforeInsert(ctx context.Context, subject *model.Lock) (bool, error)
	BeforeUpdate(ctx context.Context, old, subject *model.Lock) (bool, error)
	BeforeDelete(ctx context.Context, subject *model.Lock, opts ...DeleteOption) (bool, error)
	BeforeDeleteByID(ctx context.Context, ids []string, opts ...DeleteOption) (bool, error)
}

type lockRepository struct {
	collectionName   string
	firestoreClient  *firestore.Client
	middleware       []LockRepositoryMiddleware
	uniqueRepository *uniqueRepository
}

// NewLockRepository - constructor
func NewLockRepository(firestoreClient *firestore.Client, middleware ...LockRepositoryMiddleware) LockRepository {
	return &lockRepository{
		collectionName:   "Lock",
		firestoreClient:  firestoreClient,
		middleware:       middleware,
		uniqueRepository: newUniqueRepository(firestoreClient, "Lock"),
	}
}

func (repo *lockRepository) setMeta(subject *model.Lock, isInsert bool) {
	now := time.Now()

	if isInsert {
		subject.CreatedAt = now
	}
	subject.UpdatedAt = now
	subject.Version++
}

func (repo *lockRepository) setMetaWithStrictUpdate(param *LockUpdateParam) {
	param.UpdatedAt = firestore.ServerTimestamp
	param.Version = firestore.Increment(1)
}

func (repo *lockRepository) beforeInsert(ctx context.Context, subject *model.Lock) error {
	if subject.Version != 0 {
		return xerrors.Errorf("insert data must be Version == 0 %+v: %w", subject, ErrVersionConflict)
	}
	if subject.DeletedAt != nil {
		return xerrors.Errorf("insert data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, true)
	repo.uniqueRepository.setMiddleware(ctx)
	err := repo.uniqueRepository.CheckUnique(ctx, nil, subject)
	if err != nil {
		return xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeInsert(ctx, subject)
		if err != nil {
			return xerrors.Errorf("beforeInsert.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}

	return nil
}

func (repo *lockRepository) beforeUpdate(ctx context.Context, old, subject *model.Lock) error {
	if ctx.Value(transactionInProgressKey{}) != nil && old == nil {
		var err error
		doc := repo.GetDocRef(subject.ID)
		old, err = repo.get(context.Background(), doc)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return ErrNotFound
			}
			return xerrors.Errorf("error in Get method: %w", err)
		}
	}
	if old.Version > subject.Version {
		return xerrors.Errorf(
			"The data in the database is newer: (db version: %d, target version: %d) %+v: %w",
			old.Version, subject.Version, subject, ErrVersionConflict,
		)
	}
	if subject.DeletedAt != nil {
		return xerrors.Errorf("update data must be DeletedAt == nil: %+v", subject)
	}
	repo.setMeta(subject, false)
	repo.uniqueRepository.setMiddleware(ctx)
	err := repo.uniqueRepository.CheckUnique(ctx, old, subject)
	if err != nil {
		return xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeUpdate(ctx, old, subject)
		if err != nil {
			return xerrors.Errorf("beforeUpdate.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}

	return nil
}

func (repo *lockRepository) beforeDelete(ctx context.Context, subject *model.Lock, opts ...DeleteOption) error {
	repo.setMeta(subject, false)
	repo.uniqueRepository.setMiddleware(ctx)
	err := repo.uniqueRepository.DeleteUnique(ctx, subject)
	if err != nil {
		return xerrors.Errorf("unique.middleware error: %w", err)
	}

	for _, m := range repo.middleware {
		c, err := m.BeforeDelete(ctx, subject, opts...)
		if err != nil {
			return xerrors.Errorf("beforeDelete.middleware error: %w", err)
		}
		if !c {
			continue
		}
	}

	return nil
}

// GetCollection - *firestore.CollectionRef getter
func (repo *lockRepository) GetCollection() *firestore.CollectionRef {
	return repo.firestoreClient.Collection(repo.collectionName)
}

// GetCollectionName - CollectionName getter
func (repo *lockRepository) GetCollectionName() string {
	return repo.collectionName
}

// GetDocRef - *firestore.DocumentRef getter
func (repo *lockRepository) GetDocRef(id string) *firestore.DocumentRef {
	return repo.GetCollection().Doc(id)
}

// RunInTransaction - (*firestore.Client).RunTransaction getter
func (repo *lockRepository) RunInTransaction() func(ctx context.Context, f func(context.Context, *firestore.Transaction) error, opts ...firestore.TransactionOption) (err error) {
	return repo.firestoreClient.RunTransaction
}

// LockSearchParam - params for search
type LockSearchParam struct {
	ID           *QueryChainer
	Text         *QueryChainer
	Email        *QueryChainer
	Flag         *QueryChainer
	Interface    *QueryChainer
	MapInterface *QueryChainer
	Nested       *QueryChainer
	NestedPtr    *QueryChainer
	SliceString  *QueryChainer
	SliceNested  *QueryChainer
	CreatedAt    *QueryChainer
	CreatedBy    *QueryChainer
	UpdatedAt    *QueryChainer
	UpdatedBy    *QueryChainer
	DeletedAt    *QueryChainer
	DeletedBy    *QueryChainer
	Version      *QueryChainer

	IncludeSoftDeleted bool
	CursorKey          string
	CursorLimit        int
}

// LockUpdateParam - params for strict updates
type LockUpdateParam struct {
	Flag         interface{}
	Interface    interface{}
	MapInterface interface{}
	Nested       interface{}
	NestedPtr    interface{}
	SliceString  interface{}
	SliceNested  interface{}
	CreatedAt    interface{}
	CreatedBy    interface{}
	UpdatedAt    interface{}
	UpdatedBy    interface{}
	DeletedAt    interface{}
	DeletedBy    interface{}
	Version      interface{}
}

// Search - search documents
// The third argument is firestore.Query, basically you can pass nil
func (repo *lockRepository) Search(ctx context.Context, param *LockSearchParam, q *firestore.Query) ([]*model.Lock, error) {
	return repo.search(ctx, param, q)
}

// SearchByParam - search documents by search param
func (repo *lockRepository) SearchByParam(ctx context.Context, param *LockSearchParam) ([]*model.Lock, *PagingResult, error) {
	return repo.searchByParam(ctx, param)
}

// Get - get `Lock` by `Lock.ID`
func (repo *lockRepository) Get(ctx context.Context, id string, opts ...GetOption) (*model.Lock, error) {
	doc := repo.GetDocRef(id)
	return repo.get(ctx, doc, opts...)
}

// GetWithDoc - get `Lock` by *firestore.DocumentRef
func (repo *lockRepository) GetWithDoc(ctx context.Context, doc *firestore.DocumentRef, opts ...GetOption) (*model.Lock, error) {
	return repo.get(ctx, doc, opts...)
}

// Insert - insert of `Lock`
func (repo *lockRepository) Insert(ctx context.Context, subject *model.Lock) (_ string, err error) {
	if err := repo.beforeInsert(ctx, subject); err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}

	return repo.insert(ctx, subject)
}

// Update - update of `Lock`
func (repo *lockRepository) Update(ctx context.Context, subject *model.Lock) (err error) {
	doc := repo.GetDocRef(subject.ID)

	old, err := repo.get(ctx, doc)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return ErrNotFound
		}
		return xerrors.Errorf("error in Get method: %w", err)
	}

	if err := repo.beforeUpdate(ctx, old, subject); err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}

	return repo.update(ctx, subject)
}

// StrictUpdate - strict update of `Lock`
func (repo *lockRepository) StrictUpdate(ctx context.Context, id string, param *LockUpdateParam, opts ...firestore.Precondition) error {
	return repo.strictUpdate(ctx, id, param, opts...)
}

// Delete - delete of `Lock`
func (repo *lockRepository) Delete(ctx context.Context, subject *model.Lock, opts ...DeleteOption) (err error) {
	if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(ctx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}

	return repo.deleteByID(ctx, subject.ID)
}

// DeleteByID - delete `Lock` by `Lock.ID`
func (repo *lockRepository) DeleteByID(ctx context.Context, id string, opts ...DeleteOption) (err error) {
	subject, err := repo.Get(ctx, id)
	if err != nil {
		return xerrors.Errorf("error in Get method: %w", err)
	}

	if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(ctx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}

	return repo.Delete(ctx, subject, opts...)
}

// GetMulti - get `Lock` in bulk by array of `Lock.ID`
func (repo *lockRepository) GetMulti(ctx context.Context, ids []string, opts ...GetOption) ([]*model.Lock, error) {
	return repo.getMulti(ctx, ids, opts...)
}

// InsertMulti - bulk insert of `Lock`
func (repo *lockRepository) InsertMulti(ctx context.Context, subjects []*model.Lock) (_ []string, er error) {

	ids := make([]string, 0, len(subjects))
	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		var ref *firestore.DocumentRef
		if subject.ID == "" {
			ref = collect.NewDoc()
			subject.ID = ref.ID
		} else {
			ref = collect.Doc(subject.ID)
			if s, err := ref.Get(ctx); err == nil {
				return nil, xerrors.Errorf("already exists [%v]: %#v", subject.ID, s)
			}
		}

		if err := repo.beforeInsert(ctx, subject); err != nil {
			return nil, xerrors.Errorf("before insert error(%d) [%v]: %w", i, subject.ID, err)
		}

		batch.Set(ref, subject)
		ids = append(ids, ref.ID)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return nil, xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return ids, nil
}

// UpdateMulti - bulk update of `Lock`
func (repo *lockRepository) UpdateMulti(ctx context.Context, subjects []*model.Lock) (er error) {

	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.ID)
		snapShot, err := ref.Get(ctx)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.ID, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.ID, err)
		}

		old := new(model.Lock)
		if err = snapShot.DataTo(&old); err != nil {
			return xerrors.Errorf("error in DataTo method: %w", err)
		}

		if err := repo.beforeUpdate(ctx, old, subject); err != nil {
			return xerrors.Errorf("before update error(%d) [%v]: %w", i, subject.ID, err)
		}

		batch.Set(ref, subject)
		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMulti - bulk delete of `Lock`
func (repo *lockRepository) DeleteMulti(ctx context.Context, subjects []*model.Lock, opts ...DeleteOption) (er error) {

	batches := make([]*firestore.WriteBatch, 0)
	batch := repo.firestoreClient.Batch()
	collect := repo.GetCollection()

	for i, subject := range subjects {
		ref := collect.Doc(subject.ID)
		if _, err := ref.Get(ctx); err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found [%v]: %w", subject.ID, err)
			}
			return xerrors.Errorf("error in Get method [%v]: %w", subject.ID, err)
		}

		if err := repo.beforeDelete(ctx, subject, opts...); err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subject.ID, err)
		}

		if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
			t := time.Now()
			subject.DeletedAt = &t
			batch.Set(ref, subject)
		} else {
			batch.Delete(ref)
		}

		i++
		if (i%500) == 0 && len(subjects) != i {
			batches = append(batches, batch)
			batch = repo.firestoreClient.Batch()
		}
	}
	batches = append(batches, batch)

	for _, b := range batches {
		if _, err := b.Commit(ctx); err != nil {
			return xerrors.Errorf("error in Commit method: %w", err)
		}
	}

	return nil
}

// DeleteMultiByIDs - delete `Lock` in bulk by array of `Lock.ID`
func (repo *lockRepository) DeleteMultiByIDs(ctx context.Context, ids []string, opts ...DeleteOption) (er error) {
	subjects := make([]*model.Lock, len(ids))

	opt := GetOption{}
	if len(opts) > 0 {
		opt.IncludeSoftDeleted = opts[0].Mode == DeleteModeHard
	}
	for i, id := range ids {
		subject, err := repo.Get(ctx, id, opt)
		if err != nil {
			return xerrors.Errorf("error in Get method: %w", err)
		}
		subjects[i] = subject
	}

	return repo.DeleteMulti(ctx, subjects, opts...)
}

// SearchWithTx - search documents in transaction
func (repo *lockRepository) SearchWithTx(tx *firestore.Transaction, param *LockSearchParam, q *firestore.Query) ([]*model.Lock, error) {
	return repo.search(tx, param, q)
}

// SearchByParamWithTx - search documents by search param in transaction
func (repo *lockRepository) SearchByParamWithTx(tx *firestore.Transaction, param *LockSearchParam) ([]*model.Lock, *PagingResult, error) {
	return repo.searchByParam(tx, param)
}

// GetWithTx - get `Lock` by `Lock.ID` in transaction
func (repo *lockRepository) GetWithTx(tx *firestore.Transaction, id string, opts ...GetOption) (*model.Lock, error) {
	doc := repo.GetDocRef(id)
	return repo.get(tx, doc, opts...)
}

// GetWithDocWithTx - get `Lock` by *firestore.DocumentRef in transaction
func (repo *lockRepository) GetWithDocWithTx(tx *firestore.Transaction, doc *firestore.DocumentRef, opts ...GetOption) (*model.Lock, error) {
	return repo.get(tx, doc, opts...)
}

// InsertWithTx - insert of `Lock` in transaction
func (repo *lockRepository) InsertWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock) (_ string, err error) {
	if err := repo.beforeInsert(context.WithValue(ctx, transactionInProgressKey{}, tx), subject); err != nil {
		return "", xerrors.Errorf("before insert error: %w", err)
	}

	return repo.insert(tx, subject)
}

// UpdateWithTx - update of `Lock` in transaction
func (repo *lockRepository) UpdateWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock) (err error) {
	if err := repo.beforeUpdate(context.WithValue(ctx, transactionInProgressKey{}, tx), nil, subject); err != nil {
		return xerrors.Errorf("before update error: %w", err)
	}

	return repo.update(tx, subject)
}

// StrictUpdateWithTx - strict update of `Lock` in transaction
func (repo *lockRepository) StrictUpdateWithTx(tx *firestore.Transaction, id string, param *LockUpdateParam, opts ...firestore.Precondition) error {
	return repo.strictUpdate(tx, id, param, opts...)
}

// DeleteWithTx - delete of `Lock` in transaction
func (repo *lockRepository) DeleteWithTx(ctx context.Context, tx *firestore.Transaction, subject *model.Lock, opts ...DeleteOption) (err error) {
	if err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, tx), subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(tx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}

	return repo.deleteByID(tx, subject.ID)
}

// DeleteByIDWithTx - delete `Lock` by `Lock.ID` in transaction
func (repo *lockRepository) DeleteByIDWithTx(ctx context.Context, tx *firestore.Transaction, id string, opts ...DeleteOption) (err error) {
	subject, err := repo.Get(context.Background(), id)
	if err != nil {
		return xerrors.Errorf("error in Get method: %w", err)
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		t := time.Now()
		subject.DeletedAt = &t
		if err := repo.update(tx, subject); err != nil {
			return xerrors.Errorf("error in update method: %w", err)
		}
		return nil
	}

	if err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, tx), subject, opts...); err != nil {
		return xerrors.Errorf("before delete error: %w", err)
	}

	return repo.deleteByID(tx, id)
}

// GetMultiWithTx - get `Lock` in bulk by array of `Lock.ID` in transaction
func (repo *lockRepository) GetMultiWithTx(tx *firestore.Transaction, ids []string, opts ...GetOption) ([]*model.Lock, error) {
	return repo.getMulti(tx, ids, opts...)
}

// InsertMultiWithTx - bulk insert of `Lock` in transaction
func (repo *lockRepository) InsertMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock) (_ []string, er error) {

	ids := make([]string, len(subjects))

	for i := range subjects {
		if err := repo.beforeInsert(ctx, subjects[i]); err != nil {
			return nil, xerrors.Errorf("before insert error(%d) [%v]: %w", i, subjects[i].ID, err)
		}

		id, err := repo.insert(tx, subjects[i])
		if err != nil {
			return nil, xerrors.Errorf("error in insert method(%d) [%v]: %w", i, subjects[i].ID, err)
		}
		ids[i] = id
	}

	return ids, nil
}

// UpdateMultiWithTx - bulk update of `Lock` in transaction
func (repo *lockRepository) UpdateMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock) (er error) {
	ctx = context.WithValue(ctx, transactionInProgressKey{}, tx)

	for i := range subjects {
		if err := repo.beforeUpdate(ctx, nil, subjects[i]); err != nil {
			return xerrors.Errorf("before update error(%d) [%v]: %w", i, subjects[i].ID, err)
		}
	}

	for i := range subjects {
		if err := repo.update(tx, subjects[i]); err != nil {
			return xerrors.Errorf("error in update method(%d) [%v]: %w", i, subjects[i].ID, err)
		}
	}

	return nil
}

// DeleteMultiWithTx - bulk delete of `Lock` in transaction
func (repo *lockRepository) DeleteMultiWithTx(ctx context.Context, tx *firestore.Transaction, subjects []*model.Lock, opts ...DeleteOption) (er error) {

	t := time.Now()
	var isHardDeleteMode bool
	if len(opts) > 0 {
		isHardDeleteMode = opts[0].Mode == DeleteModeHard
	}
	opt := GetOption{
		IncludeSoftDeleted: isHardDeleteMode,
	}
	for i := range subjects {
		dr := repo.GetDocRef(subjects[i].ID)
		if _, err := repo.get(context.Background(), dr, opt); err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found(%d) [%v]", i, subjects[i].ID)
			}
			return xerrors.Errorf("error in get method(%d) [%v]: %w", i, subjects[i].ID, err)
		}

		if err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, tx), subjects[i], opts...); err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subjects[i].ID, err)
		}

		if !isHardDeleteMode {
			subjects[i].DeletedAt = &t
			if err := repo.update(tx, subjects[i]); err != nil {
				return xerrors.Errorf("error in update method(%d) [%v]: %w", i, subjects[i].ID, err)
			}
		}
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		return nil
	}

	for i := range subjects {
		if err := repo.deleteByID(tx, subjects[i].ID); err != nil {
			return xerrors.Errorf("error in delete method(%d) [%v]: %w", i, subjects[i].ID, err)
		}
	}

	return nil
}

// DeleteMultiByIDWithTx - delete `Lock` in bulk by array of `Lock.ID` in transaction
func (repo *lockRepository) DeleteMultiByIDsWithTx(ctx context.Context, tx *firestore.Transaction, ids []string, opts ...DeleteOption) (er error) {

	t := time.Now()
	for i := range ids {
		dr := repo.GetDocRef(ids[i])
		subject, err := repo.get(context.Background(), dr)
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return xerrors.Errorf("not found(%d) [%v]", i, ids[i])
			}
			return xerrors.Errorf("error in get method(%d) [%v]: %w", i, ids[i], err)
		}

		if err := repo.beforeDelete(context.WithValue(ctx, transactionInProgressKey{}, tx), subject, opts...); err != nil {
			return xerrors.Errorf("before delete error(%d) [%v]: %w", i, subject.ID, err)
		}

		if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
			subject.DeletedAt = &t
			if err := repo.update(tx, subject); err != nil {
				return xerrors.Errorf("error in update method(%d) [%v]: %w", i, ids[i], err)
			}
		}
	}

	if len(opts) > 0 && opts[0].Mode == DeleteModeSoft {
		return nil
	}

	for i := range ids {
		if err := repo.deleteByID(tx, ids[i]); err != nil {
			return xerrors.Errorf("error in delete method(%d) [%v]: %w", i, ids[i], err)
		}
	}

	return nil
}

func (repo *lockRepository) get(v interface{}, doc *firestore.DocumentRef, opts ...GetOption) (*model.Lock, error) {
	var (
		snapShot *firestore.DocumentSnapshot
		err      error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		snapShot, err = x.Get(doc)
	case context.Context:
		snapShot, err = doc.Get(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", x)
	}

	if err != nil {
		if status.Code(err) == codes.NotFound {
			return nil, ErrNotFound
		}
		return nil, xerrors.Errorf("error in Get method: %w", err)
	}

	subject := new(model.Lock)
	if err := snapShot.DataTo(&subject); err != nil {
		return nil, xerrors.Errorf("error in DataTo method: %w", err)
	}

	if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
		if subject.DeletedAt != nil {
			return nil, ErrAlreadyDeleted
		}
	}
	subject.ID = snapShot.Ref.ID

	return subject, nil
}

func (repo *lockRepository) getMulti(v interface{}, ids []string, opts ...GetOption) ([]*model.Lock, error) {
	var (
		snapShots []*firestore.DocumentSnapshot
		err       error
		collect   = repo.GetCollection()
		drs       = make([]*firestore.DocumentRef, len(ids))
	)

	for i, id := range ids {
		ref := collect.Doc(id)
		drs[i] = ref
	}

	switch x := v.(type) {
	case *firestore.Transaction:
		snapShots, err = x.GetAll(drs)
	case context.Context:
		snapShots, err = repo.firestoreClient.GetAll(x, drs)
	default:
		return nil, xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return nil, xerrors.Errorf("error in GetAll method: %w", err)
	}

	subjects := make([]*model.Lock, 0, len(ids))
	mErr := NewMultiErrors()
	for i, snapShot := range snapShots {
		if !snapShot.Exists() {
			mErr = append(mErr, NewMultiError(i, ErrNotFound))
			continue
		}

		subject := new(model.Lock)
		if err = snapShot.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}

		if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
			if subject.DeletedAt != nil {
				mErr = append(mErr, NewMultiError(i, ErrLogicallyDeletedData))
				continue
			}
		}
		subject.ID = snapShot.Ref.ID
		subjects = append(subjects, subject)
	}

	if len(mErr) == 0 {
		return subjects, nil
	}

	return subjects, mErr
}

func (repo *lockRepository) insert(v interface{}, subject *model.Lock) (string, error) {
	var (
		dr  = repo.GetCollection().NewDoc()
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Create(dr, subject)
	case context.Context:
		_, err = dr.Create(x, subject)
	default:
		return "", xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		if status.Code(err) == codes.AlreadyExists {
			return "", xerrors.Errorf("error in Create method: err=%+v: %w", err, ErrAlreadyExists)
		}
		return "", xerrors.Errorf("error in Create method: %w", err)
	}

	subject.ID = dr.ID

	return dr.ID, nil
}

func (repo *lockRepository) update(v interface{}, subject *model.Lock) error {
	var (
		dr  = repo.GetDocRef(subject.ID)
		err error
	)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Set(dr, subject)
	case context.Context:
		_, err = dr.Set(x, subject)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Set method: %w", err)
	}

	return nil
}

func (repo *lockRepository) strictUpdate(v interface{}, id string, param *LockUpdateParam, opts ...firestore.Precondition) error {
	var (
		dr  = repo.GetDocRef(id)
		err error
	)

	repo.setMetaWithStrictUpdate(param)

	updates := updater(model.Lock{}, param)

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Update(dr, updates, opts...)
	case context.Context:
		_, err = dr.Update(x, updates, opts...)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Update method: %w", err)
	}

	return nil
}

func (repo *lockRepository) deleteByID(v interface{}, id string) error {
	dr := repo.GetDocRef(id)
	var err error

	switch x := v.(type) {
	case *firestore.Transaction:
		err = x.Delete(dr, firestore.Exists)
	case context.Context:
		_, err = dr.Delete(x, firestore.Exists)
	default:
		return xerrors.Errorf("invalid type: %v", v)
	}

	if err != nil {
		return xerrors.Errorf("error in Delete method: %w", err)
	}

	return nil
}

func (repo *lockRepository) runQuery(v interface{}, query firestore.Query) ([]*model.Lock, error) {
	var iter *firestore.DocumentIterator

	switch x := v.(type) {
	case *firestore.Transaction:
		iter = x.Documents(query)
	case context.Context:
		iter = query.Documents(x)
	default:
		return nil, xerrors.Errorf("invalid type: %v", v)
	}

	defer iter.Stop()

	subjects := make([]*model.Lock, 0)

	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return nil, xerrors.Errorf("error in Next method: %w", err)
		}

		subject := new(model.Lock)

		if err = doc.DataTo(&subject); err != nil {
			return nil, xerrors.Errorf("error in DataTo method: %w", err)
		}

		subject.ID = doc.Ref.ID
		subjects = append(subjects, subject)
	}

	return subjects, nil
}

// BUG(54m): there may be potential bugs
func (repo *lockRepository) searchByParam(v interface{}, param *LockSearchParam) ([]*model.Lock, *PagingResult, error) {
	query := func() firestore.Query {
		return repo.GetCollection().Query
	}()
	if param.ID != nil {
		for _, chain := range param.ID.QueryGroup {
			var value interface{}
			switch val := chain.Value.(type) {
			case string:
				value = repo.GetDocRef(val)
			case []string:
				docRefs := make([]*firestore.DocumentRef, len(val))
				for i := range val {
					docRefs[i] = repo.GetDocRef(val[i])
				}
				value = docRefs
			default:
				return nil, nil, xerrors.Errorf("document id can only be of type `string` and `[]string`. value: %#v", chain.Value)
			}
			query = query.Where(firestore.DocumentID, chain.Operator, value)
		}
		if direction := param.ID.OrderByDirection; direction > 0 {
			query = query.OrderBy(firestore.DocumentID, direction)
			query = param.ID.BuildCursorQuery(query)
		}
	}
	if param.Text != nil {
		for _, chain := range param.Text.QueryGroup {
			query = query.Where("text", chain.Operator, chain.Value)
		}
		if direction := param.Text.OrderByDirection; direction > 0 {
			query = query.OrderBy("text", direction)
			query = param.Text.BuildCursorQuery(query)
		}
	}
	if param.Email != nil {
		for _, chain := range param.Email.QueryGroup {
			query = query.Where("Email", chain.Operator, chain.Value)
		}
		if direction := param.Email.OrderByDirection; direction > 0 {
			query = query.OrderBy("Email", direction)
			query = param.Email.BuildCursorQuery(query)
		}
	}
	if param.Flag != nil {
		for _, chain := range param.Flag.QueryGroup {
			items, ok := chain.Value.(map[string]float64)
			if !ok {
				continue
			}
			for key, value := range items {
				query = query.WherePath(firestore.FieldPath{"flag", key}, chain.Operator, value)
			}
		}
	}
	if param.Interface != nil {
		for _, chain := range param.Interface.QueryGroup {
			query = query.Where("interface", chain.Operator, chain.Value)
		}
		if direction := param.Interface.OrderByDirection; direction > 0 {
			query = query.OrderBy("interface", direction)
			query = param.Interface.BuildCursorQuery(query)
		}
	}
	if param.MapInterface != nil {
		for _, chain := range param.MapInterface.QueryGroup {
			items, ok := chain.Value.(map[string]interface{})
			if !ok {
				continue
			}
			for key, value := range items {
				query = query.WherePath(firestore.FieldPath{"map_interface", key}, chain.Operator, value)
			}
		}
	}
	if param.Nested != nil {
		for _, chain := range param.Nested.QueryGroup {
			query = query.Where("nested", chain.Operator, chain.Value)
		}
		if direction := param.Nested.OrderByDirection; direction > 0 {
			query = query.OrderBy("nested", direction)
			query = param.Nested.BuildCursorQuery(query)
		}
	}
	if param.NestedPtr != nil {
		for _, chain := range param.NestedPtr.QueryGroup {
			query = query.Where("nested_ptr", chain.Operator, chain.Value)
		}
		if direction := param.NestedPtr.OrderByDirection; direction > 0 {
			query = query.OrderBy("nested_ptr", direction)
			query = param.NestedPtr.BuildCursorQuery(query)
		}
	}
	if param.SliceString != nil {
		for _, chain := range param.SliceString.QueryGroup {
			query = query.Where("slice_string", chain.Operator, chain.Value)
		}
	}
	if param.SliceNested != nil {
		for _, chain := range param.SliceNested.QueryGroup {
			query = query.Where("slice_nested", chain.Operator, chain.Value)
		}
	}
	if param.CreatedAt != nil {
		for _, chain := range param.CreatedAt.QueryGroup {
			query = query.Where("createdAt", chain.Operator, chain.Value)
		}
		if direction := param.CreatedAt.OrderByDirection; direction > 0 {
			query = query.OrderBy("createdAt", direction)
			query = param.CreatedAt.BuildCursorQuery(query)
		}
	}
	if param.CreatedBy != nil {
		for _, chain := range param.CreatedBy.QueryGroup {
			query = query.Where("createdBy", chain.Operator, chain.Value)
		}
		if direction := param.CreatedBy.OrderByDirection; direction > 0 {
			query = query.OrderBy("createdBy", direction)
			query = param.CreatedBy.BuildCursorQuery(query)
		}
	}
	if param.UpdatedAt != nil {
		for _, chain := range param.UpdatedAt.QueryGroup {
			query = query.Where("updatedAt", chain.Operator, chain.Value)
		}
		if direction := param.UpdatedAt.OrderByDirection; direction > 0 {
			query = query.OrderBy("updatedAt", direction)
			query = param.UpdatedAt.BuildCursorQuery(query)
		}
	}
	if param.UpdatedBy != nil {
		for _, chain := range param.UpdatedBy.QueryGroup {
			query = query.Where("updatedBy", chain.Operator, chain.Value)
		}
		if direction := param.UpdatedBy.OrderByDirection; direction > 0 {
			query = query.OrderBy("updatedBy", direction)
			query = param.UpdatedBy.BuildCursorQuery(query)
		}
	}
	if param.DeletedAt != nil {
		for _, chain := range param.DeletedAt.QueryGroup {
			query = query.Where("deletedAt", chain.Operator, chain.Value)
		}
		if direction := param.DeletedAt.OrderByDirection; direction > 0 {
			query = query.OrderBy("deletedAt", direction)
			query = param.DeletedAt.BuildCursorQuery(query)
		}
	}
	if param.DeletedBy != nil {
		for _, chain := range param.DeletedBy.QueryGroup {
			query = query.Where("deletedBy", chain.Operator, chain.Value)
		}
		if direction := param.DeletedBy.OrderByDirection; direction > 0 {
			query = query.OrderBy("deletedBy", direction)
			query = param.DeletedBy.BuildCursorQuery(query)
		}
	}
	if param.Version != nil {
		for _, chain := range param.Version.QueryGroup {
			query = query.Where("version", chain.Operator, chain.Value)
		}
		if direction := param.Version.OrderByDirection; direction > 0 {
			query = query.OrderBy("version", direction)
			query = param.Version.BuildCursorQuery(query)
		}
	}
	if !param.IncludeSoftDeleted {
		query = query.Where("deletedAt", OpTypeEqual, nil)
	}

	limit := param.CursorLimit + 1

	if param.CursorKey != "" {
		var (
			ds  *firestore.DocumentSnapshot
			err error
		)
		switch x := v.(type) {
		case *firestore.Transaction:
			ds, err = x.Get(repo.GetDocRef(param.CursorKey))
		case context.Context:
			ds, err = repo.GetDocRef(param.CursorKey).Get(x)
		default:
			return nil, nil, xerrors.Errorf("invalid x type: %v", v)
		}
		if err != nil {
			if status.Code(err) == codes.NotFound {
				return nil, nil, ErrNotFound
			}
			return nil, nil, xerrors.Errorf("error in Get method: %w", err)
		}
		query = query.StartAt(ds)
	}

	if limit > 1 {
		query = query.Limit(limit)
	}

	subjects, err := repo.runQuery(v, query)
	if err != nil {
		return nil, nil, xerrors.Errorf("error in runQuery method: %w", err)
	}

	pagingResult := &PagingResult{
		Length: len(subjects),
	}
	if limit > 1 && limit == pagingResult.Length {
		next := pagingResult.Length - 1
		pagingResult.NextCursorKey = subjects[next].ID
		subjects = subjects[:next]
		pagingResult.Length--
	}

	return subjects, pagingResult, nil
}

func (repo *lockRepository) search(v interface{}, param *LockSearchParam, q *firestore.Query) ([]*model.Lock, error) {
	if (param == nil && q == nil) || (param != nil && q != nil) {
		return nil, xerrors.New("either one should be nil")
	}

	query := func() firestore.Query {
		if q != nil {
			return *q
		}
		return repo.GetCollection().Query
	}()

	if q == nil {
		subjects, _, err := repo.searchByParam(v, param)
		if err != nil {
			return nil, xerrors.Errorf("error in searchByParam method: %w", err)
		}

		return subjects, nil
	}

	return repo.runQuery(v, query)
}

// GetByText - get by Text
func (repo *lockRepository) GetByText(ctx context.Context, text string, opts ...GetOption) (*model.Lock, error) {
	return repo.getByXXX(ctx, "text", text, opts...)
}

// GetByTextWithTx - get by Text in transaction
func (repo *lockRepository) GetByTextWithTx(tx *firestore.Transaction, text string, opts ...GetOption) (*model.Lock, error) {
	return repo.getByXXX(tx, "text", text, opts...)
}

// GetByEmail - get by Email
func (repo *lockRepository) GetByEmail(ctx context.Context, email string, opts ...GetOption) (*model.Lock, error) {
	return repo.getByXXX(ctx, "Email", email, opts...)
}

// GetByEmailWithTx - get by Email in transaction
func (repo *lockRepository) GetByEmailWithTx(tx *firestore.Transaction, email string, opts ...GetOption) (*model.Lock, error) {
	return repo.getByXXX(tx, "Email", email, opts...)
}

func (repo *lockRepository) getByXXX(v interface{}, field, value string, opts ...GetOption) (*model.Lock, error) {
	query := repo.GetCollection().Query.Where(field, OpTypeEqual, value)
	if len(opts) == 0 || !opts[0].IncludeSoftDeleted {
		query = query.Where("deletedAt", OpTypeEqual, nil)
	}
	query = query.Limit(1)
	results, err := repo.runQuery(v, query)
	if err != nil {
		return nil, xerrors.Errorf("failed to run query: %w", err)
	} else if len(results) == 0 {
		return nil, ErrNotFound
	}
	return results[0], nil
}
